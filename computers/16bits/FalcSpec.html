From rmccall@mcs.dundee.ac.uk (Rod McCall)
Newsgroups: comp.sys.atari.st,comp.sys.atari.st.tech
Subject: Falcon Spec Sheet
Date: 12 Dec 1994 10:18:59 GMT


Okay, here it comes...again!!!

 Atari Falcon 030 Specifications
 -------------------------------
 
 CPU: Motorola 68030 32-bit microprocessor @ 16MHz w/ 32-bit bus
 FPU: Motorola 68881/68882 @ 16MHz (optional)
 DSP: Motorola 56001 Digital Signal Processor running in parallel @ 32MHz 
         w/ 32kWords (24-bit) of local zero wait state static RAM
 ROM: 512kB
 RAM: 1, 4 or 16MB(14MB usable) on daughterboard (RAM is 32-bit wide)
 
 Expansion bus: Internal 'Processor-Direct' slot for 386SX emulation 
                (third party 386SX emulator nearly completed) or other 
                co-processors/etc.
 
 Video: (See below for specific video modes/resolutions.)
        16-bit BLiTTER @ 16MHz (also handles hard drive access)
        Accepts external video sync to allow high quality genlocking
        Overlay mode for easy video titling and special effects
        Overscan support
        Hardware-assisted horizontal fine scrolling
        VIDEL (video controller) sits on 32-bit bus
 
 Audio: Stereo 16-bit Analog-to-Digital DMA input
        Stereo 16-bit Digital-to-Analog DMA output
        Eight 16-bit audio DMA record/playback channels
        SDMA sound/DMA co-processor
        
 Ports: 128kB cartridge port
        2 9-pin mouse/joystick ports
        2 15-pin STe enhanced analog/digital controller ports (Atari also 
           has new analog controllers w/ a joystick, 3 fire buttons, and a 
           12-key keypad)
        MIDI IN, OUT/THRU
        Bi-directional parallel port
        RS232C serial port
        SCSI II w/ DMA
        Analog RGB/VGA/composite video connector
        Stereo headphone out (1/8" mini-jack)
        Stereo microphone in (1/8" mini-jack)
        DSP port (up to 1MHz data transfer rate)
        RF modulator for TV hookup
        Localtalk compatible LAN (up to 250kbaud transfer rate)
 
 Misc:  Internal 1.44MB 3.5" HD floppy
        Internal IDE 2.5" hard drive (optional)
        Pre-emptive mulitasking OS (MultiTOS) w/ adaptive prioritization 
           and inter-process communication (also 68040 compatible)
        Realtime clock and battery backed up RAM
        1040ST-style case w/ internal fan
        North American availability in mid-October
 
 Price: 1MB/no HD -  $799 list
        4MB/65MB  - $1399 list


     Resolutions available on the Atari Falcon030 (c) 1992 Atari Corp.
                         Written by John Townsend
 =========================================================================
 This document may be re-printed again and again as long as the Atari 
 copyright remains intact.
 =========================================================================

 A couple of notes: Unlike previous machines, there are just too many
 resolutions to give each resolution a name. Therefore, I will do my best
 to describe what the resolution is and which monitor it is on.

 - NOTE: TV and a Color Monitor are the same.. by Color Monitor, I am
   talking about the standard SC1224. By VGA, I mean a standard VGA
   Monitor.

 40 column modes ( "column" means the number of x pixels divided by 8)
 ---------------
    4 color, normal, TV:         320x200,    4 colors, 2 planes
   16 color, normal, TV:         320x200,   16 colors, 4 planes
  256 color, normal, TV:         320x200,  256 colors, 8 planes
 True color, normal, TV:         320x200,  true color

    4 color, interlace, TV:      320x400,    4 colors, 2 planes
   16 color, interlace, TV:      320x400,   16 colors, 4 planes
  256 color, interlace, TV:      320x400,  256 colors, 8 planes
 True color, interlace, TV:      320x400,  true color

    4 color, normal, VGA:        320x480,    4 colors, 2 planes
   16 color, normal, VGA:        320x480,   16 colors, 4 planes
  256 color, normal, VGA:        320x480,  256 colors, 8 planes
 True color, normal, VGA:        320x480,  true color

    4 color, line-doubling, VGA: 320x240,    4 colors, 2 planes
   16 color, line-doubling, VGA: 320x240,   16 colors, 4 planes
  256 color, line-doubling, VGA: 320x240,  256 colors, 8 planes
 True color, line-doubling, VGA: 320x240,  true color

 80 column modes
 ---------------
    2 color, normal, TV:         640x200,    2 colors, 1 plane
    4 color, normal, TV:         640x200,    4 colors, 2 planes
   16 color, normal, TV:         640x200,   16 colors, 4 planes
  256 color, normal, TV:         640x200,  256 colors, 8 planes
 True color, normal, TV:         640x200,  true color

    4 color, interlace, TV:      640x400,    4 colors, 2 planes
   16 color, interlace, TV:      640x400,   16 colors, 4 planes
  256 color, interlace, TV:      640x400,  256 colors, 8 planes
 True color, interlace, TV:      640x400,  true color

    2 color, normal, VGA:        640x480,    2 colors, 1 plane
    4 color, normal, VGA:        640x480,    4 colors, 2 planes
   16 color, normal, VGA:        640x480,   16 colors, 4 planes
  256 color, normal, VGA:        640x480,  256 colors, 8 planes

    4 color, line-doubling, VGA: 640x240,    4 colors, 2 planes
   16 color, line-doubling, VGA: 640x240,   16 colors, 4 planes
  256 color, line-doubling, VGA: 640x240,  256 colors, 8 planes

and lastly.. there are compability modes for ST Low, ST Medium, and ST 
High on both VGA monitors and SC1224 monitors. (On a color monitor, ST 
High is achieved by using the interlace mode).

Also, the ST Monochrome monitor (the SM124) will work with Falcon030 as 
well. However, it only supports one resolution: ST High Resolution.

All modes on a TV can be overscanned. This means multiplying the X and Y
resolution by 1.2. For example, modes with 320 pixels of horizontal 
resolution (X res) will become 384 pixels across, and modes with 640 
pixels will become 768 across. Overscanning is done in the X and Y 
resolution. You can't do them independently. Special Note: On a VGA 
monitor, overscan is "faked".. since the video hardware doesn't have the 
capability to do overscan on a VGA monitor, we made it so that if a 
overscan mode is set on a VGA monitor, you still see the normal size 
screen, but the screen is a window onto the bigger overscanned image. 
Make sense? We did this for compatibility. This way if a game that has an 
overscanned starup picture can use the same pic on both the VGA monitor 
and the TV monitor. Pretty cool, eh? <grin>

BTW.. Overscan can NOT be set from the desktop. The AES and Desktop will 
work just fine with it, but because you can't see the parts of the 
screen, we thought that that option shouldn't be available from the 
desktop. We don't want to confuse people. However, Overscan can be set 
using a new XBIOS call (Vsetmode()).. so it is still available.

I hope I haven't made any mistakes. I triple-checked this document in 
search of errors and I couldn't find any. If you do find some, send me 
Email on GEnie (to TOWNS) or CIS (70007,1135) and let me know.

-- John Townsend, Atari Corp.

P.S. Anyone who would like to reprint this message, please do so!
     The smaller the number of times I have to type that message, the
     more my fingers with thank you! ;-)

     After looking at this one more time.. one point to clear up: By
     saying SC1224 Color Monitor, I mean any Color Monitor that Atari
     have manufactured for the ST/Mega/STE/MegaSTE computers. Clear
     as mud? ;-)


Article: 33384 of comp.sys.atari.st
Path: i2unix!corton!mcsun!sun4nl!alchemy!piet
>From: piet@cs.ruu.nl (Piet van Oostrum)
Newsgroups: comp.sys.atari.st
Subject: Re: The REAL Falcon specs wanted!
Keywords: Falcon specs.
Message-ID: <1992Sep1.120211.6162@cs.ruu.nl>
Date: 1 Sep 92 12:02:11 GMT
References: <1992Aug31.123840.1064@ludd.luth.se> <1992Aug31.195705.18207@athena.cs.uga.edu>
Sender: network-news@cs.ruu.nl
Reply-To: piet@cs.ruu.nl (Piet van Oostrum)
Organization: Dept of Computer Science, Utrecht University, The Netherlands
Lines: 470
In-Reply-To: kjohnson@castor.cs.uga.edu (Kristopher Johnson)

I found this file on the local ATARI Company's BBS : (original in Dutch)

This article is written by Wilfred Kilwinger (Support Manager) for
Atari Briefing, the newsletter by Atari (Benelux) B.V. for the Atari 
user groups. It was specifically stated that it could be reproduced. I have
translated it in English with the assumption that an English translation
would be considered the same as the original.

The original also contained a description of all the features of the Falcon
which have been reproduced here a zillion of times so I did not include
these. 

------------------------------------------------------------------------
Atari custom chips

VIDEL

The VIDEL takes care of the video functions of the system including
overscan, overlay mode and true color graphics

COMBEL

The COMBEL is the system manager of the Atari Falcon030. This chip controls
all system functions. Also the BLITTER is built in in this chip.

SDMA

The SDMA is the Sound DMA and controls the sound part. We have built in a
unique matrix switch function in this chip (more details in the second part)

KEYBOARD PROCESSOR

The keyboard processor has been improved and is now also suitable for high
resolution mice.

Besides the above custom chips the Atari Falcon030 has a number of standard
chips like the Motorola 68030 and 56001 DSP. Another important chip is the
CODEC in which the 16 bit AD and DA converters are located.

Video modi

As you can see in the survey of Operating System calls
the video hardware is complete sotware controllable. The following
combinations can a.o. be chosen:

Mode      Resolution  Bit planes  Colors  Palette

ST LOW     320x200       4           16     4096
ST MED     640x200       2            4     4096
ST HIGH    640x400       1            2     4096

True Color 640x480       8          256   262144
           320x200     15bpp      32768     N/A

The last mode asks for some explanation. Here there is no color palette but
15 bits per pixel to describe the pixel itself. The format is
RRRRRGGGGGXBBBBB. VDI supports this mode thus programs that have not been
written for this mode specifically can use it nevertheless.
X is the overlay bit and can be used for video titling and special effects.

          320x200     16bpp      65         N/A

This mode is called the slideshow mode, is not supported by the VDI, you
are on you own. X is an extra green bit.


True Color in 640x480 is not possible because of the bandwidth of VGA monitors.

Mode      Resolution Bit planes   Colors    Palette

VGA      320 of 640   1,4,8       2,16,256  262144 (Overscan 
Video    200 of 400

With Video we mean the Atari SC-monitors, the TV modulator and/or the
composite video output.

All modes can be gegenlocked. With adaptors we convert
the 15-pole video bus to thee standard Atari or VGA connections.

       |----|
       -    -
      /      \
     /        \
    /          \
    |          |
    -|--------|-


Matrix coupling

To make the system performance in the audio part as good as possible Atari
designed a miniature 'telephone exchange' that can easily connect the
source devices to the receiving devices. Also it is possible to make more
than one connection at a time.


    Source devices

        EXT INPUT ---*-------*------*------*
         CHANNEL     |       |      |      |
                     |       |      |      |
           DSP    ---*-------*------*------*
        TRANSMIT     |       |      |      |
                     |       |      |      |
           ADC    ---*-------*------*------*
                     |       |      |      |
                     |       |      |      |
           DMA    ---*-------*------*------*
        PLAYBACK     |       |      |      |
                    DMA     DAC    DSP     EXT OUTPUT
                   RECORD        RECEIVE     CHANNEL

                        Receiving Devices


Ports andn interfacing

DSP CONNECTOR (DB26 Female)

Pin   Signal                           Pin   Signal

1     GP0                              14    GND
2     GP1                              15    SRD
3     GP2                              16    GND
4     P_DATA                           17    +12V
5     P_CLK                            18    GND
6     P_SYNC                           19    R_DATA
7     n/c                              20    R_CLK
8     GND                              21    R_SYNC
9     +12V                             22    EXT_INT
10    GND                              23    STD
11    SC0                              24    SCK
12    SC1                              25    GND
13    SC2                              26    EXCLK                         


SCSI CONNECTOR (flat 50 pins SCSI II Female)

Pin   Signal                           Pin   Signal

1-10  GND                              37    Not Connected
11    +5V                              38    +5V
12-14 Not Connected                    39    Not Connected
15-25 GND                              40    GND
26    SCSI 0                           41    ATN
27    SCSI 1                           42    GND
28    SCSI 2                           43    BSY
29    SCSI 3                           44    ACK
30    SCSI 4                           45    RST
31    SCSI 5                           46    MSG
32    SCSI 6                           47    SEL
33    SCSI 7                           48    C/D
34    Parity                           49    REQ
35-36 GND                              50    I/O


SERIAL PORT (DB9 MALE)                                                         

Pin   Signal

1     Carrier Detect                   5     GND
2     Receive                          6     Data set ready
3     Transmit                         7     Request to Send
4     Data Terminal Ready              8     Clear to Send
                                       9     Ring Indicator

PARALLEL PORT (DB25 Female)

The parallel port has extra signal to ease the connection of scanners.

Pin   Signal

1     Strobe          8     Data 6
2     Data 0          9     Data 7
3     Data 1         10     Acknowledge
4     Data 2         11     Busy
5     Data 3         12-16  Not Connected
6     Data 4         17     Select
7     Data 5         18-25  GND


MONITOR CONNECTOR (DB19 Male)

Pin   Signal                           Pin   Signal

1     Red                              11    GND
2     Green                            12    Composite Sync/Video
3     Blue                             13    Horizontal Sync
4     Mono/Overlay                     14    Vertical Sync
5     GND                              15    External Clock Input
6     Red GND                          16    External SYNC Enable
7     Green GND                        17    +12V
8     Blue GND                         18    M1
9     Audio out                        19    M0
10    GND


SCC LAN-port CONNECTOR (8-pin Mini DIN Female RS-422)

Pin   Signal

1     Handshake Output (DTR RS 423)           5     - Received Data
2     Handshake Input or External Clock       6     + Transmitted Data
3     - Transmit Data                         7     General-purpose Input
4     GND                                     8     + Receive


ENHANCED JOYSTICK (DB15 Male)

Port A                                 Port B

Pin   Signal                           Pin   Signal

1     UP 0                             1     UP 1
2     DOWN 0                           2     DOWN 1
3     LT 0                             3     LT 1
4     RT 0                             4     RT 1
5     PAD0Y                            5     PAD1Y
6     FIRE 0 / LIGHT GUN               6     FIRE 1
7     VCC (+5 VDC)                     7     VCC
8     Not Connected                    8     Not Connected
9     GND                              9     GND
10    FIRE 2                           10    FIRE 3
11    UP 2                             11    UP 3
12    DOWN 2                           12    DOWN 3
13    LT 2                             13    LT 3
14    RT 2                             14    RT 3
15    PAD0X                            15    PAD1X                    


MIDI PORT (DIN 5 Female)

MIDI OUT                               MIDI  IN

Pin   Signal                           Pin   Signal

1     Thru Transmit                    1     Not Connected
2     GND                              2     Not Connected
3     Thru Loop Return                 3     Not Connected
4     Out Transmit                     4     In Receive
5     Out Loop Return                  5     In Loop Return


New Operating System calls

This information is not complete, maybe subject to change and is certainly
not meant as documentation for programmers

DSP-calls

Dsp_DoBlock(a,b,c,d)                    (void) xbios(500,a,b,c,d)
Dsp_BlkHandShake(a,b,c,d)               (void) xbios(501,a,b,c,d)
Dsp_BlkUnpacked(a,b,c,d)                (void) xbios(502,a,b,c,d)
Dsp_InStream(a,b,c,d)                   (void) xbios(503,a,b,c,d)
Dsp_OutStream(a,b,c,d)                  (void) xbios(504,a,b,c,d)
Dsp_IOStream(a,b,c,d,e,f)               (void) xbios(505,a,b,c,d,e,f)
Dsp_RemoveInterrupts(a)                 (void) xbios(506,a)
Dsp_GetWordSize()                       (int)  xbios(507)
Dsp_Lock()                              (int)  xbios(508)
Dsp_Unlock()                            (void) xbios(509)
Dsp_Available(a,b)                      (void) xbios(510,a,b)
Dsp_Reserve(a,b)                        (int) xbios(511,a,b)
Dsp_LoadProg(a,b,c)                     (int) xbios(512,a,b,c)
Dsp_ExecProg(a,b,c)                     (void) xbios(513,a,b,c)
Dsp_ExecBoot(a,b,c)                     (void) xbios(514,a,b,c)
Dsp_LodToBinary(a,b)                    (long) xbios(515,a,b)
Dsp_TriggerHC(a)                        (void) xbios(516,a)
Dsp_RequestUniqueAbility()              (int)  xbios(517)
Dsp_GetProgAbility()                    (int)  xbios(518)
Dsp_FlushSubroutines()                  (void) xbios(519)
Dsp_LoadSubroutine(a,b,c)               (int)  xbios(520,a,b,c)
Dsp_InqSubrAbility(a)                   (int)  xbios(521,a)
Dsp_RunSubroutine(a)                    (int)  xbios(522,a)
Dsp_Hf0(a)                              (int)  xbios(523,a)
Dsp_Hf1(a)                              (int)  xbios(524,a)
Dsp_Hf2()                               (int)  xbios(525)
Dsp_Hf3()                               (int)  xbios(526)
Dsp_BlkWords(a,b,c,d)                   (void) xbios(527,a,b,c,d)
Dsp_BlkBytes(a,b,c,d)                   (void) xbios(528,a,b,c,d)
Dsp_HStat()                             (char) xbios(529)
Dsp_SetVectors(a,b)                     (void) xbios(530,a,b)
 
De volledige beschrijving van bovenstaande functie's staat in de Falcon030 
Developers Documentation.

 
VIDEO SETMODE

int setmode( int modecode );

The setmode( int modecode ) call is used to place the Falcon/030 SHIFTER
into a specific mode. A bit-encoded value (called a "modecode") is passed
to setmode() to set the mode. setmode() returns the previous mode that 
was set.

To help make the building of modecode values easier, here is a table of
defines:

        #define VERTFLAG        0x100
        #define STMODES         0x80
        #define OVERSCAN        0x40
        #define PAL             0x20
        #define VGA             0x10
        #define TV              0x0

        #define COL80           0x08
        #define COL40           0x0
        #define NUMCOLS         7

        #define BPS16           4
        #define BPS8            3
        #define BPS4            2
        #define BPS2            1
        #define BPS1            0

Using these defines, you can build a modecode for any possible mode.
For example:

        For True Color Overscan:
        modecode = OVERSCAN|COL40|BPS16;
        
        For ST Medium Compatibility mode on a Color Monitor/TV:
        modecode = STMODES|COL80|BPS2;

        For ST Low Compatibility mode in PAL on a Color Monitor/TV:
        modecode = STMODES|PAL|COL80|BPS2;

        For 256 color, 80 column mode on a VGA monitor:
        modecode = VGA|COL80|BPS8;

If you have a modecode and wish to know how many bits per pixel it
has, use the following:

        if( modecode & NUMCOLS ) == BPS16 )
                do_something_cool();    /* You have true color mode */

The setmode() call will return the previous modecode set. You must use
this value to get back to whatever mode you were in before you made your 
setmode call.


int mon_type(void)

The mon_type() function will return the kind of monitor that is currently
in use. Here are the possible return values:

        0 = ST monochrome monitor
        1 = ST color monitor
        2 = VGA monitor
        3 = Television. 


void ext_sync( int flag )

This function sets or clears external sync. If flag is set, external 
sync is enabled. If flag is clear, then internal sync is used.


SOUND-calls

locksnd();
Used as a semiphore to lock the sound system. From other applications.

unlocksnd();    
Used to release the sound system for other applications to use.

soundcmd(mode,data);
This command is used to get or set the following sound parameters.
If a negative number is used as the input then the current setting us
returned.

MODE    OPERATION       MEANING 

O       LTATTEN Sets the current left channel output

1       RTATTEN Sets the current right channel output

2       LTGAIN  Sets the current left channel input gain.

3       RTGAIN  Sets the current right channel input gain.

4       ADDERIN Set the output of the 16 bit signed adder to
                receive it's input from the ADC, Matrix or
                both.

5       ADCINPUT        Set the input the the ADC. The input can either
                        be the left and right channel of the PSG or the
                        left and right channel of the microphone.

6       SETPRESCALE     Used for compatability. This prescale value
                        is used when the DEVCONNECT() internal
                        prescale value is set to zero.


setbuffer(reg,begaddr,endaddr);
This function is used to set the play or record buffers. REG selects
playback or record, while begaddr and endaddr are the buffers beginning
and ending locations.

        (int)   reg             - (0) Sets playback registers.
                                - (1) Sets record registers.
        (long)  begaddr - Sets the beginning address of the buffer.
        (long)  endaddr - Sets the ending address of the buffer.

setmode(mode);
This function is used to set record or playback mode. The modes are as
follows:

MODE            OPERATION
(int)   0      8 Bit Stereo
(int)   1      16 Bit Stereo
(int)   2      8 Bit Mono

settracks(playtracks,rectracks);
This function is used to sets the number of record or playback tracks.

setmontracks(montrack);
This function is used to set the output of the internal speaker to one of
the four tracks currently playing. The internal speaker is only capable of
outputing ONE track at a time.

setinterrupt(src_inter,cause);
This function is used to set which interrupt that will occur at the end of a
frame. If the frame repeat bit is on, this interrupt is used to allow for 
double buffering the playing or recording of sound. Interrupts can come from
TimerA or the MFP i7.

buffoper(mode);
This function is used to control the operation of the play or record buffers
in the sound system. The input to this function is a bitmap. If mode is set
t0 -1 then the current status of the buffer operation bits is returned.

NOTE:   The sound system contains a 32 byte FIFO. When transferring data to 
the record buffer, software MUST check to see if the record enable (RE) bit 
was cleared by the hardware. If the bit was cleared then the FIFO is flushed,
if not then software must flush the FIFO by clearing the record enable (RE)
bit. 

dsptristate(dspxmit,dsprec);
This function is used to tristate the DSP from the data matrix. 

gpio(mode,data);
This is used to communicate over the General Purpose I/O on the DSP connector.
Only the low order three bits are used. The rest are reserved. This call,
depending on the mode, can be used to set the direction of the I/O bits, read
the bits, or write the bits. 

devconnect(src,dst,srcclk,prescale,protocol);
This function is used to attach a source device to any of the destination
devices in the matrix. Given a source device, this call will attach that one
source device to one or all of the destination devices. This call also sets
up the source clock and prescaler, protocol and protocol source if used.

sndstatus(reset);
This function gets the current status of the codec.

buffptr(pointer);
This function returns the current position of the play and record data buffer
pointers. These pointers indicate where the data is being read/written within
the buffers themselves. This function is also used to  determine how much
data has been written to the record buffer. See buffoper().


The above is not yet complete. Atari has also routines for
JPEG and andio conversion.
-- 
Piet* van Oostrum, Dept of Computer Science, Utrecht University,
Padualaan 14, P.O. Box 80.089, 3508 TB Utrecht, The Netherlands.
Telephone: +31 30 531806   Uucp:   uunet!mcsun!ruuinf!piet
Telefax:   +31 30 513791   Internet:  piet@cs.ruu.nl   (*`Pete')


Article: 6027 of comp.sys.atari.st.tech
Path: i2unix!corton!mcsun!uunet!van-bc!jonh.wimsey.bc.ca!jhenders
>From: jhenders@jonh.wimsey.bc.ca ( John Henders )
Newsgroups: comp.sys.atari.st.tech
Subject: Re: DSP in the Falcon
Message-ID: <H.op5odQJVpyw@jonh.wimsey.bc.ca>
Date: 1 Sep 92 01:20:24 GMT
References: <H.H8xksAVnXI6@kynes.bison.mb.ca> <469@muller.loria.fr>
Reply-To: jhenders@jonh.wimsey.bc.ca
Organization: One of these days for sure
Lines: 27
X-Software: HERMES GUS 1.03 Rev. Apr 14 1992

In <469@muller.loria.fr>, Steven Eker writes:
>
>Things which the 56001 should be useful for include software sound synthesis
>& matrix*vector multiplcation (the basis of 3D vector games).
>
>If the DSP DMA is implemented right (does anyone have a programmer eye view of
>this yet?) is should be possible to use it as an extremely fast graphi